import numpy as npfrom numpy.linalg import invfrom scipy import integratea = np.array([[1, 1, 1], [2, 1, 1], [2, 2, 1]])a1 = np.array([[1,1,1], [2,2,1], [1,2,1]])b = np.array([[-1,  1,  0], [ 0, -1,  1], [ 2,  0, -1]])my = np.matrix.transpose(b)def dJ( u, v, p1, p2, p3 ):    x1, y1 = p1    x2, y2 = p2    x3, y3 = p3    dxdu = ( (1-v)*x2 + v*x3 - x1 )    dxdv = ( u*x3 - u*x2 )    dydu = ( (1-v)*y2 + v*y3 - y1 )    dydv = ( u*y3 - u*y2 )    return np.abs( dxdu*dydv - dxdv*dydu )def tridblquad(integrand, p1, p2, p3):    '''    Perform double quadtrature integration on triangular domain.    Input: function to integrate, points of triangle as tuples.    Output: integral and estimated absolute error as a tuple.    '''    x1, y1 = p1;    x2, y2 = p2;    x3, y3 = p3    # transformation to the unit square    g = lambda u, v, c1, c2, c3: (1 - u) * c1 + u * ((1 - v) * c2 + v * c3)    # transformation for the integrand,    # including the Jacobian scaling factor    def h(u, v):        x = g(u, v, x1, x2, x3)        y = g(u, v, y1, y2, y3)        I = integrand(x, y)        I *= dJ(u, v, p1, p2, p3)        return I    # perfrom the double integration using quadrature in the transformed space    integral, error = integrate.dblquad(h, 0, 1, lambda x: 0, lambda x: 1, epsrel=1e-6, epsabs=0)    return integral, errorarea, _ = tridblquad( lambda x, y: 1, (1.,1.), (1.,2.), (2.,2.) )print 'Area: {}'.format( area )